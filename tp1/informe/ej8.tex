\section{Ejercicio 8}
\label{fig:ej8-intro}
Realizamos las mediciones sobre un lote de tareas $TaskCPU$,
ya que los schedulers SJF y RSJF solo soportan tareas de este tipo.

\begin{center}
\fbox{\parbox{6cm}
    {\noindent
        TaskCPU 10 \\
        TaskCPU 20 \\
        @4: \\
        TaskCPU 5 \\
        TaskCPU 5 \\
        TaskCPU 5
    }
}
\end{center}
\captionof{figure}{Lote de tareas}
\label{fig:ej8-t1}
\vspace*{1em}

\subsection{Mediciones sobre un solo núcleo}

Primero realizamos mediciones ejecutando sobre un solo núcleo.

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-rr}
        \caption{Ejecución sobre un único core del lote de la figura
            \ref{fig:ej8-t1} con el scheduler RoundRobin}
        \label{fig:ej8-cpu-rr}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-fcfs}
        \caption{Ejecución sobre un único core del lote de la figura
            \ref{fig:ej8-t1} con el scheduler FIFO}
        \label{fig:ej8-cpu-fcfs}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-sjf}
        \caption{Ejecución sobre un único core del lote de la figura
            \ref{fig:ej8-t1} con el scheduler SJF}
        \label{fig:ej8-cpu-sjf}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-rsjf}
        \caption{Ejecución sobre un único core del lote de la figura
            \ref{fig:ej8-t1} con el scheduler RSJF}
        \label{fig:ej8-cpu-rsjf}
\end{figure}

\begin{center}
        \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
                \hline
    Task & \multicolumn{4}{c |}{Waiting-time} & \multicolumn{4}{c |}{Latencia} & \multicolumn{4}{c |}{Turnaround} \\
                \cline{2-13}
          & RR & FIFO & SJF & RSJF & RR & FIFO & SJF & RSJF & RR & FIFO & SJF & RSJF \\
                \hline
    0 &       39 &   1 &   1 &  20 &        1 &   1 &   1 &   1 &       44 &  11 &  11 &  30 \\
    1 &       37 &  12 &  30 &  35 &        6 &  12 &  30 &  31 &       57 &  32 &  50 &  55 \\
    2 &       28 &  29 &   8 &   2 &        7 &  29 &   8 &   2 &       33 &  34 &  13 &   7 \\
    3 &       30 &  35 &  14 &   8 &       12 &  35 &  14 &   8 &       35 &  40 &  19 &  13 \\
    4 &       32 &  46 &  20 &  14 &       17 &  46 &  20 &  14 &       37 &  46 &  25 &  19 \\
                \hline
		\label{tab:tabla4}
        \end{tabular}
\end{center}
\captionof{table}{Mediciones sobre un solo core
                  usando el lote de tareas de la figura \ref{fig:ej8-t1}}

Con estos valores podemos calcular el promedio de cada métrica para cada scheduler.

\begin{center}
        \begin{tabular}{| l | c | c | c |}
                \hline
    Scheduler & Waiting-time & Latencia & Turnaround \\
                \hline
    RR   &    33.5 &  8.6 & 41.2 \\
    FIFO &    24.6 & 24.6 & 32.6 \\
    SJF  &    14.6 & 14.6 & 23.6 \\
    RSJF &    15.8 & 11.2 & 24.8 \\
                \hline
			\label{tab:tabla5}
        \end{tabular}
\end{center}
\captionof{table}{Promedio de métricas sobre un solo core
                  usando el lote de tareas de la figura \ref{fig:ej8-t1}}

\subsection{Mediciones sobre dos núcleos}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-rr-m}
        \caption{Ejecución sobre dos cores del lote de la figura
            \ref{fig:ej8-t1} con el scheduler RoundRobin}
        \label{fig:ej8-cpu-rr-m}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-fcfs-m}
        \caption{Ejecución sobre dos cores del lote de la figura
            \ref{fig:ej8-t1} con el scheduler FIFO}
        \label{fig:ej8-cpu-fcfs-m}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-sjf-m}
        \caption{Ejecución sobre dos cores del lote de la figura
            \ref{fig:ej8-t1} con el scheduler SJF}
        \label{fig:ej8-cpu-sjf-m}
\end{figure}

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{ej8-cpu-rsjf-m}
        \caption{Ejecución sobre dos cores del lote de la figura
            \ref{fig:ej8-t1} con el scheduler RSJF}
        \label{fig:ej8-cpu-rsjf-m}
\end{figure}

\begin{center}
       \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
                \hline
    Task & \multicolumn{4}{c |}{Waiting-time} & \multicolumn{4}{c |}{Latencia} & \multicolumn{4}{c |}{Turnaround} \\
                \cline{2-13}
          & RR & FIFO & SJF & RSJF & RR & FIFO & SJF & RSJF & RR & FIFO & SJF & RSJF \\
                \hline
    0 &       16 &   1 &   1 &  10 &        1 &   1 &   1 &   1 &       26 &  11 &  11 &  20 \\
    1 &       17 &   1 &   1 &  16 &        1 &   1 &   1 &   1 &       37 &  21 &  21 &  36 \\
    2 &       12 &   8 &   8 &   2 &        2 &   8 &   8 &   2 &       17 &  13 &  13 &   7 \\
    3 &       14 &  14 &  14 &   2 &        2 &  14 &  14 &   2 &       19 &  19 &  19 &   7 \\
    4 &       15 &  18 &  18 &   8 &        7 &  18 &  18 &   8 &       20 &  23 &  23 &  13 \\
                \hline
	\label{tab:tabla6}        

        \end{tabular}
        
\end{center}
\captionof{table}{Mediciones sobre dos cores
                  usando el lote de tareas de la figura \ref{fig:ej8-t1}}
   

Con estos valores podemos calcular el promedio de cada métrica para cada scheduler.

\begin{center}
        \begin{tabular}{| l | c | c | c |}
                \hline
    Scheduler & Waiting-time & Latencia & Turnaround \\
                \hline
    RR   &    14.8 &  2.6 & 23.8 \\
    FIFO &     8.4 &  8.4 & 17.4 \\
    SJF  &     8.4 &  8.4 & 17.4 \\
    RSJF &     7.6 &  2.8 & 16.6 \\
                \hline
	\label{tab:tabla7}
        \end{tabular}
\end{center}
\captionof{table}{Promedio de métricas sobre dos cores
                  usando el lote de tareas de la figura \ref{fig:ej8-t1}}

\subsection{Conclusiones}

\ \ Al ver los resultados obtenidos en la \hyperref[tab:tabla7]{tabla 7} se puede notar, como era de esperarse, que los Schedulers Reentrantes, Round Robin y RSJF, consiguen una $latencia$ promedio menor debido a su forma de elección de procesos más justa, este resultado se repite tambien al experimentar con un solo nucleo (Ver \hyperref[tab:tabla5]{tabla 5}) aunque no es tan significativa la diferencia. En la \hyperref[tab:tabla7]{tabla 7} FIFO tiene una latencia de mas del triple que RSJF mientras que en la \hyperref[tab:tabla5]{tabla 5} solo del doble. Por otro lado, para el $Waiting$-$Time$ y $Turnaround$, el Scheduler $Round-Robin$ no parece desempeñarse demasiado bien habiendo conseguido en promedio 14.8 y 23.8 respectivamente con dos nucleos (Ver \hyperref[tab:tabla7]{tabla 7}) lo cual es bastante inferior a los resultados de los demás schedulers que consiguieron, en el peor de los casos, 8.4 y 17.4 de Waiting-time y Turnaround promedio. Esto es entendible ya que al permitir que los procesos se vayan turnando se provoca que todos esperen una mayor cantidad de tiempo y tarden más en terminar. El otro Scheduler Reentrante, RSJF al no ser completamente justo, sino que le da prioridad a los procesos que duran menos, logra perder algunas de las desventajas que Round Robin presenta y consigue algunas de las ventajas de sus contrapartes no reentrantes como FIFO y SJF, este consiguio los mejores valores 7.6 y 16.6 para el experimento multicore (Ver \hyperref[tab:tabla7]{tabla 7}) y el segundo lugar por una diferencia menor al 20\% en el experimento con un solo núcleo (Ver \hyperref[tab:tabla5]{tabla 5}). En el caso de RSJF particularmente se pierde menos tiempo por no tener que cambiar tanto entre contextos sobre el final cuando las tareas se vuelven extremadamente cortas en tiempo restante, algo que sí sucede con Round-Robin. Con $RSJF$, en la \hyperref[fig:ej8-cpu-rsjf]{figura 17}, siempre se extiende el turno actual un poco más para terminar con estos pequeños restos (las tareas de 5 ciclos de longitud, a pesar de tener turnos de 4 ciclos, se ejecutan siempre enteras).

\ \ Siguiendo con la idea de contrastar reentrantes y no reentrantes, cuando analizamos para múltiples cores (Ver las figuras en la sección \hyperref[fig:ej8-cpu-rr-m]{Mediciones sobre dos núcleos}) se puede notar que además de que los reentrantes terminan el lote en mayor cantidad de ciclos a causa del task-switching, terminan destinando más tiempo de cpu a la tarea $IDLE$ (lo cual no es problemático, pero indica de manera clara que la ejecución termina siendo más asimétrica). Esto último seguramente viene del hecho de que, \hyperref[fig:ej8-intro]{en el lote de testeo}, las tareas más longevas son aquellas que primero se cargan. A raíz de esto, los no-reentrantes se ocupan primero de las que más tiempo de ejecución consumen para luego terminar con las más cortas, que además son similares en longitud y, por lo tanto, los cpus ejecutan y terminan de manera relativamente pareja sin que ninguno se extienda demasiado.
