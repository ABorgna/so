\section{RWLock}

\subsection{Pseudocódigo de los algoritmos}

El objetivo del $RWLock$ es restringir el acceso a una variable (Un tablero en el caso del juego) de modo que cualquier cantidad de lectores pueda leer los datos simultáneamente pero solo puedan escribir de a uno por vez y cuando nadie esté leyendo.

Los algoritmos descriptos a continuación son parte de los métodos de la clase RWLock, la cual esta formada por un mutex $m$, una variable de condición $turn$ y tres int $reading$, $writing$ y $writers$, los cuales se describen a continuación.

Los algoritmos de bloqueo, rlock y wlock funcionan chequeando que las condiciones son aptas para realizar su acción (leer o escribir respectivamente) y luego indicando que van a realizar dicha acción a través de las variables $reading$ y $writing$. Estas variables indican cuantas personas están leyendo o escribiendo, en el caso de $reading$ la cantidad puede ser un numero positivo o cero ya que no hay problema en que múltiples personas lean una variable, por otra parte $writing$ solo puede valor 0 o 1 ya que no puede permitirse que múltiples personas estén editando la misma variable porque generaría $race\ conditions$. La variable $writers$ indicará cuantas personas quieren escribir.

Se puede apreciar que se da prioridad a la escritura dado que, si en algún momento hay algún thread leyendo, mientras otros están esperando para leer y otro thread ya se declaró writer, tendrán que esperar a que procese el writer por más que podría comenzar a leer en simultáneo con el otro lector ya declarado.

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \caption{Pseudocódigo del bloqueador para lectura}
  \label{algo:3-1}
  \Procedure{rlock}{$ $}
	\State $mutex\_lock(\&m)$

	\While {$ writers $}
		\State $ cond\_wait(\&turn, \&m) $
	\EndWhile
	\While {$ writing $}
		\State $ cond\_wait(\&turn, \&m) $
	\EndWhile
	
	\State $reading$ $\leftarrow$ $reading + 1$
	\State $mutex\_unlock(\&m)$

	\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \caption{Pseudocódigo del bloqueador para escritura}
  \label{algo:3-1}
  \Procedure{wlock}{$ $}
	\State $mutex\_lock(\&m)$

	\While {$ writers $}
		\State $ cond\_wait(\&turn, \&m) $
	\EndWhile
	\State $writers$ $\leftarrow$ $writers + 1$
	\While {$reading$ $or$ $writing$}
		\State $ cond\_wait(\&turn, \&m) $
	\EndWhile
	
	\State $writing$ $\leftarrow$ $writing + 1$

	\State $mutex\_unlock(\&m)$

	\EndProcedure
	\end{algorithmic}
\end{algorithm}

Los algoritmos de desbloqueo, runlock y wunlock, funcionan avisando que el usuario ya concluyó el proceso de lectura o escritura disminuyendo las variables $writing$ y $writers$ o $reading$ según corresponda. Luego de disminuir la/las variables se lo comunica a todas las variables de condición que estén esperando a través de $cond\_broadcast$.

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \caption{Pseudocódigo del desbloqueador para lectura}
  \label{algo:3-1}
  \Procedure{runlock}{$ $}
	\State $mutex\_lock(\&m)$

	\State $reading$ $\leftarrow$ $reading - 1$
	
	\State $cond\_broadcast(\&turn)$

	\State $mutex\_unlock(\&m)$

	\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
  \caption{Pseudocódigo del desbloqueador para escritura}
  \label{algo:3-1}
  \Procedure{wunlock}{$ $}
	\State $mutex\_lock(\&m)$

	\State $writing$ $\leftarrow$ $writing - 1$
	
	\State $writers$ $\leftarrow$ $writers - 1$
	
	\State $cond\_broadcast(\&turn)$

	\State $mutex\_unlock(\&m)$

	\EndProcedure
	\end{algorithmic}
\end{algorithm}

Como último detalle es importante mencionar que al haber muchos threads intentando escribir estos van a acumularse esperando en la variable de condición hasta ser despertados, esta situación puede ser problemática, ya que se va a ir despertando a cada thread (para que bloquee el mutex y continue con su ejecución) de a uno por vez y podría ocurrir, según como este implementado el scheduller que cierto thread se quede esperando, debido a que, por ejemplo, siempre pasan primero nuevos threads que van llegando, esto claramente generaría un problema de inanición. Para este trabajo vamos a asumir que dicho fenomeno no puede ocurrir debido a que tenemos un scheduller que ordena de alguna manera suficientemente justa los threads de tal manera que se forma una especie de cola que define un orden de llegada entre los mismos. Para evitar asumir esto pensamos en armar una cola con un mutex pero creemos que iria en contra de la idea del trabajo práctico y al consultarlo nos dijeron que no era necesario enfrentar este problema.

\subsection{Referencias}

Como guía para desarrollar este trabajo utilizamos lo visto en la clase práctica y teórica sobre pthreads acompañado de los ejemplos y explicaciones desarrolladas en la página del $LLNL$. Para consultas sobre $POSIX$ $threads$ recurrimos a Source Ware.

\begin{itemize}

\item \href{https://computing.llnl.gov/tutorials/pthreads/}{Tutorial del LLNL}

\item \href{https://www.sourceware.org/pthreads-win32/manual/}{Source Ware}

\end{itemize}

\subsection{Explicación de los tests desarrollados}

Nuestro test pone a prueba el buen funcionamiento de la clase RWLock verificando que, al menos para lo testeado hasta el momento, no hay señales de condiciones de carrera, deadlocks o inanición. 

Como test desarrollamos un programa que hace correr simultáneamente varios threads. Estos leen y escriben una variable local de tipo $int$, la cual inicia valiendo cero. Hay un RWLock global que comparten todos los threads, estos utilizan los métodos de bloqueo y desbloqueo para asegurar una buena sincronización al escribir o leer.

Cada thread empieza leyendo $variable\_global$, utilizando $rlock$ y $runlock$ al principio y final respectivamente. Luego hace un bloqueo de escritura $wlock$, aumenta en 1 a $variable\_global$ y luego la decrementa (también en 1), se imprime el resultado y se desbloquea con $wunlock$. Esto es para chequear que al escribir sobre la variable, solo lo hace un único thread, si esto se cumple, la impresión del valor de la variable debería ser siempre $0$, si no fuera así entonces al menos dos procesos estuvieron accediendo simultáneamente a la variable.

Se corrió el test con el RWLock y luego sin (comentando las lineas relacionadas a bloqueos y desbloqueos). Y se confirmo que en el primer caso se imprimía siempre 0 como valor resultante y en el segundo no necesariamente, obteniendo todo tipo de valores. Esto verifica que no hay condiciones de carrera. El test siempre finaliza exitosamente con cada thread terminado correctamente por lo que tampoco se observan señales de deadlocks o inanición.
