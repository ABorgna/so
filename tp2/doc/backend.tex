\section{Servidor de backend}

En esta sección se irán enumerando los cambios realizados sobre el juego original para cumplir con los requisitos dados.

Para permitir que múltiples clientes se conecten al backend de forma simultánea editamos el $main$ de $backend.cpp$ hicimos que no se cierre el socket del servidor al conectarse un usuario, sino que este se mantenga abierto para permitir que nuevos jugadores se conecten. Ahora cada vez que alguien se conecta se crea un nuevo $thread$ que ejecuta, al igual que en la versión mono, a $atendedor\_de\_jugador$.

Como decisión de diseñó preferimos modelar el tablero del juego a partir de una sola matriz $tablero$ en vez de un $tablero\_temporal$ y $tablero\_confirmado$. De esta manera se permite para una casilla tener el RESERVADO, definido como 0x01 en $Encabezado.h$, esto indica que un jugador escogió poner una carta sobre la casilla pero aún no confirmó la jugada. Haciendo esto pudimos luego modelar fácilmente la restricción de un jugador para escoger una casilla reservada.

Otro pequeño cambio fue que las variables $socketfd\_cliente$ y $socket\_size$ se cambiaron de $int$ a $long$ ya que el primero es un tipo de datos de 32 bits pero por lo que al castearlo a un puntero \textit{void} (de 64b) podía llegar a generar problemas.

Se agregó $tablero\_lock$ en $backend.cpp$, la variable local que utilizaremos para coordinar las escrituras y lecturas del tablero, evitando condiciones de carrera y obteniendo un manejo sincronizado del tablero.

De esta manera se agregaron locks y unlocks donde fue necesario, más específicamente en los siguientes métodos

\begin{itemize}

\item $\mathbf{atendedor\_de\_jugador}:$

\begin{itemize}
\item Se bloquea para escritura. Así agrega una nueva ficha a una jugada tras haber tomado el lock y llamado a $es\_ficha\_valida\_en\_jugada$ sin soltarlo, de modo que nadie pudo haber ocupado el casillero elegido entre que fue leído (para corroborar que el movimiento fuera válido) y reservado por el jugador. Por eso que no podemos leer primero el tablero con lock de lectura y luego otro lock escribir, envolviendo ambas en un único lock de escritura.

\item Se bloquea para escritura, así puede escribir sobre el tablero la jugada confirmada.

\end{itemize}

\item $\mathbf{enviar\_tablero}:$

\begin{itemize}

\item Se bloquea para lectura, así no envía un tablero con una jugada a medio hacer.

\end{itemize}

\item $\mathbf{quitar\_cartas:}$

\begin{itemize}

\item Se bloquea para escritura. Así puede eliminar cartas del tablero de forma completa y evitar que un usuario pueda leer o escribir en un tablero con una jugada a medio quitar.

\end{itemize}

\end{itemize}
